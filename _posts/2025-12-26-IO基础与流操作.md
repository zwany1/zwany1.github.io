---
layout: post
title: IO基础与流操作
categories: [Java]
tags: [IO, Stream, NIO, 文件传输]
---

简要导读：本文覆盖 IO 流核心概念、字节流与字符流的常用操作，以及大文件断点续传的实战方案（本地与 HTTP Range）。

- 目录
  - [IO流核心概念](#io-core)
  - [字节流操作](#byte-stream)
  - [字符流操作](#char-stream)
  - [实战应用：大文件断点续传](#resume)

## IO流核心概念 {: #io-core}

- 抽象分层：`InputStream/OutputStream`（字节）、`Reader/Writer`（字符）
- 阻塞与非阻塞：经典 IO 为阻塞；`NIO` 通过缓冲区与通道提升吞吐
- 编码转换：字符流负责字节⇄字符的编码解码（如 UTF-8、GBK）

```java
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class CopyBytes {
    public static void main(String[] args) throws Exception {
        try (InputStream in = new FileInputStream("src.bin");
             OutputStream out = new FileOutputStream("dst.bin")) {
            byte[] buf = new byte[8192];
            int n;
            while ((n = in.read(buf)) != -1) {
                out.write(buf, 0, n);
            }
            out.flush();
        }
    }
}
```

## 字节流操作 {: #byte-stream}

- 输入：`InputStream` 关键方法 `read(...)`、`skip(...)`、`available()`、`close()`
- 输出：`OutputStream` 关键方法 `write(...)`、`flush()`、`close()`
- 性能：使用缓冲包装如 `BufferedInputStream/BufferedOutputStream`
- 大文件：优先使用 `NIO FileChannel.transferTo/transferFrom`

```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class BufferedCopy {
    public static void main(String[] args) throws Exception {
        try (BufferedInputStream in = new BufferedInputStream(new FileInputStream("in.dat"));
             BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream("out.dat"))) {
            byte[] buf = new byte[16 * 1024];
            int n;
            while ((n = in.read(buf)) != -1) {
                out.write(buf, 0, n);
            }
            out.flush();
        }
    }
}
```

```java
import java.nio.channels.FileChannel;
import java.nio.file.StandardOpenOption;
import java.nio.file.Path;

public class NioTransfer {
    public static void main(String[] args) throws Exception {
        try (FileChannel src = FileChannel.open(Path.of("big.src"), StandardOpenOption.READ);
             FileChannel dst = FileChannel.open(Path.of("big.dst"), StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            long size = src.size();
            long pos = 0;
            while (pos < size) {
                long sent = src.transferTo(pos, size - pos, dst);
                pos += sent;
            }
        }
    }
}
```

## 字符流操作 {: #char-stream}

- 适用场景：文本处理与编码转换（避免中文乱码）
- 桥接：`InputStreamReader`/`OutputStreamWriter` 在字节与字符之间转换
- 常用：`BufferedReader`/`BufferedWriter` 处理按行文本

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;

public class TextProcess {
    public static void main(String[] args) throws Exception {
        try (BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
             BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String transformed = line.toUpperCase();
                writer.write(transformed);
                writer.newLine();
            }
            writer.flush();
        }
    }
}
```

```java
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class CharsetConvert {
    public static void main(String[] args) throws Exception {
        try (InputStreamReader reader = new InputStreamReader(new FileInputStream("gbk.txt"), "GBK");
             OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream("utf8.txt"), StandardCharsets.UTF_8)) {
            char[] buf = new char[4096];
            int n;
            while ((n = reader.read(buf)) != -1) {
                writer.write(buf, 0, n);
            }
            writer.flush();
        }
    }
}
```

## 实战应用：大文件断点续传 {: #resume}

- 本地续传：使用 `RandomAccessFile + FileChannel`，记录进度到文件
- HTTP 续传：使用 `Range` 请求头进行断点下载
- 分片合并：后端合并分片到目标文件，按序零拷贝写入

```java
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.ByteBuffer;
import java.nio.file.Path;
import java.nio.file.Files;

public class ResumeCopy {
    public static void main(String[] args) throws Exception {
        Path srcPath = Path.of("huge.src");
        Path dstPath = Path.of("huge.dst");
        Path progressPath = Path.of("huge.progress");

        long offset = Files.exists(progressPath) ? Long.parseLong(Files.readString(progressPath)) : 0L;

        try (RandomAccessFile src = new RandomAccessFile(srcPath.toFile(), "r");
             RandomAccessFile dst = new RandomAccessFile(dstPath.toFile(), "rw");
             FileChannel srcCh = src.getChannel();
             FileChannel dstCh = dst.getChannel()) {
            dstCh.position(offset);
            long pos = offset;
            long size = srcCh.size();
            ByteBuffer buf = ByteBuffer.allocateDirect(8 * 1024 * 1024);
            while (pos < size) {
                buf.clear();
                int read = srcCh.read(buf, pos);
                if (read < 0) break;
                buf.flip();
                while (buf.hasRemaining()) {
                    dstCh.write(buf);
                }
                pos += read;
                Files.writeString(progressPath, Long.toString(pos));
            }
        }

        if (Files.size(dstPath) == Files.size(srcPath)) {
            Files.deleteIfExists(progressPath);
        }
    }
}
```

```java
import java.net.HttpURLConnection;
import java.net.URL;
import java.io.InputStream;
import java.io.RandomAccessFile;

public class HttpRangeDownload {
    public static void main(String[] args) throws Exception {
        String fileUrl = "https://example.com/large.bin";
        String target = "large.bin";
        String progressFile = "large.bin.offset";

        long offset = 0L;
        java.nio.file.Path p = java.nio.file.Path.of(progressFile);
        if (java.nio.file.Files.exists(p)) {
            offset = Long.parseLong(java.nio.file.Files.readString(p));
        }

        HttpURLConnection conn = (HttpURLConnection) new URL(fileUrl).openConnection();
        conn.setRequestProperty("Range", "bytes=" + offset + "-");
        conn.connect();

        try (InputStream in = conn.getInputStream();
             RandomAccessFile raf = new RandomAccessFile(target, "rw")) {
            raf.seek(offset);
            byte[] buf = new byte[8192];
            int n;
            long pos = offset;
            while ((n = in.read(buf)) != -1) {
                raf.write(buf, 0, n);
                pos += n;
                java.nio.file.Files.writeString(p, Long.toString(pos));
            }
        }
    }
}
```

```java
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.util.List;

public class MergeChunksFast {
    public static void merge(String targetFile, List<String> chunkFiles) throws Exception {
        try (RandomAccessFile raf = new RandomAccessFile(targetFile, "rw")) {
            FileChannel out = raf.getChannel();
            long position = 0;
            for (String chunk : chunkFiles) {
                try (RandomAccessFile chunkRaf = new RandomAccessFile(chunk, "r")) {
                    FileChannel in = chunkRaf.getChannel();
                    long size = in.size();
                    long sent = 0;
                    while (sent < size) {
                        sent += in.transferTo(sent, size - sent, out.position(position + sent));
                    }
                    position += size;
                }
            }
            out.truncate(position);
        }
    }
}
```
